---
phase: 01-specification
plan: 01
type: execute
---

<objective>
Document Steps 1-3 (Load EA, Inject, Compile, Extract Params) - the preparation phase.

Purpose: Create complete specifications for the initial workflow steps that prepare an EA for testing.
Output: 5 spec files (steps 1, 1b, 1c, 2, 3) in `.planning/phases/01-specification/specs/`
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-specification/01-CONTEXT.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STRUCTURE.md

**Source files to analyze:**
@engine/runner.py (steps 1, 1b, 1c, 2, 3 implementations)
@engine/gates.py (gate functions)
@engine/state.py (state management)
@modules/injector.py (step 1b, 1c implementation)
@modules/compiler.py (step 2 implementation)
@modules/params.py (step 3 implementation)

**Reference for step contracts:**
@CLAUDE.md (step table and documentation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create spec directory and template</name>
  <files>.planning/phases/01-specification/specs/</files>
  <action>Create the specs directory. Create a template structure that each spec will follow:

  ```markdown
  # Step X: Name

  ## Overview
  [What this step does]

  ## Inputs
  [Exact inputs with types and sources]

  ## Outputs
  [Exact outputs with types and destinations]

  ## Gate
  [Pass/fail conditions with thresholds]

  ## Implementation Notes
  [Current behavior, edge cases, known issues]

  ## Skill Integration
  [If LLM skills interact with this step]
  ```

  Document this template in a README.md in the specs directory.</action>
  <verify>ls .planning/phases/01-specification/specs/ shows README.md</verify>
  <done>Template documented, directory created</done>
</task>

<task type="auto">
  <name>Task 2: Document Steps 1, 1B, 1C (Load and Inject)</name>
  <files>.planning/phases/01-specification/specs/step-01-load-ea.md, .planning/phases/01-specification/specs/step-01b-inject-ontester.md, .planning/phases/01-specification/specs/step-01c-inject-safety.md</files>
  <action>Read the relevant source code sections and create complete specs:

  **Step 1 (Load EA):**
  - Read `_step_load_ea()` in runner.py
  - Read `check_file_exists()` in gates.py
  - Document: input path validation, gate condition, error handling

  **Step 1B (Inject OnTester):**
  - Read `_step_inject_ontester()` in runner.py
  - Read `create_modified_ea()` in modules/injector.py
  - Document: what gets injected, why (OnTester function for optimization metrics), modified file location

  **Step 1C (Inject Safety):**
  - Read `_step_inject_safety()` in runner.py
  - Read `inject_safety_inputs()` in modules/injector.py
  - Document: safety parameters added, default values, how they're used in later steps

  For each spec, extract exact behavior from code - don't invent requirements.</action>
  <verify>All 3 spec files exist with complete Inputs/Outputs/Gate sections</verify>
  <done>Steps 1, 1B, 1C fully documented with code-derived specifications</done>
</task>

<task type="auto">
  <name>Task 3: Document Steps 2, 3 (Compile and Extract)</name>
  <files>.planning/phases/01-specification/specs/step-02-compile.md, .planning/phases/01-specification/specs/step-03-extract-params.md</files>
  <action>Read the relevant source code sections and create complete specs:

  **Step 2 (Compile):**
  - Read `_step_compile()` in runner.py
  - Read modules/compiler.py
  - Document: compiler invocation, error parsing, success/failure detection, output paths
  - Note: This is where /mql5-fixer skill intervenes on failure

  **Step 3 (Extract Params):**
  - Read `_step_extract_params()` in runner.py
  - Read modules/params.py
  - Document: param extraction method, param format, what gets extracted (name, type, default, min, max, step)
  - Note: Workflow pauses here for LLM analysis

  For each spec, capture the exact data formats and structures used.</action>
  <verify>All spec files exist with complete Inputs/Outputs/Gate sections</verify>
  <done>Steps 2, 3 fully documented with code-derived specifications</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All 5 spec files exist in .planning/phases/01-specification/specs/
- [ ] Each spec has: Overview, Inputs, Outputs, Gate, Implementation Notes
- [ ] Specs reference actual code locations (file:line)
- [ ] Data formats are concrete (example JSON/dict structures)
- [ ] Gate conditions include thresholds from settings.py
</verification>

<success_criteria>

- All 5 specs created (step-01, step-01b, step-01c, step-02, step-03)
- Each spec is self-contained (reader can implement from spec alone)
- Skill integration points documented where relevant
- Known issues/bugs flagged for later phases
  </success_criteria>

<output>
After completion, create `.planning/phases/01-specification/01-01-SUMMARY.md`:

---
phase: 01-specification
plan: 01
subsystem: specification
requires: []
provides: [step-1-spec, step-1b-spec, step-1c-spec, step-2-spec, step-3-spec]
affects: [01-02, 02-core-domain]
key-decisions: []
key-files: [.planning/phases/01-specification/specs/step-01-load-ea.md, .planning/phases/01-specification/specs/step-02-compile.md, .planning/phases/01-specification/specs/step-03-extract-params.md]
---

# Phase 01-specification Plan 01: Preparation Steps Summary

**[One-liner summary of what was documented]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- [List of spec files]

## Decisions Made

[Key decisions about spec format, or "None"]

## Issues Encountered

[Problems found during extraction, or "None"]

## Next Step

Ready for 01-02-PLAN.md (Steps 4-5 validation)
</output>
