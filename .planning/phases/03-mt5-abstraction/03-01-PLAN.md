---
phase: 03-mt5-abstraction
plan: 01
type: execute
---

<objective>
Build MT5 abstraction layer with interface, real implementation, and dry-run capability.

Purpose: Enable testable workflow stages by abstracting MT5 operations behind a protocol. This allows unit testing without MT5 and clean separation between "what operations exist" and "how MT5 does them."

Output: `ea_stress/mt5/` package with interface protocol, terminal implementation wrapping existing modules, and dry-run mock for testing.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase (domain models we'll use):
@.planning/phases/02-core-domain/02-01-SUMMARY.md

# Existing modules to wrap:
@modules/compiler.py
@modules/backtest.py
@modules/optimizer.py

# Domain models available:
@ea_stress/core/__init__.py
@ea_stress/core/params.py
@ea_stress/core/metrics.py

**Tech stack available:** Python dataclasses, typing.Protocol
**Established patterns:** Frozen dataclasses for results, to_dict/from_dict for serialization
**Constraining decisions:**
- Phase 2: Domain models use dataclasses with explicit type hints
- Phase 2: Validation returns list of error messages (empty = valid)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MT5 interface protocol</name>
  <files>ea_stress/mt5/__init__.py, ea_stress/mt5/interface.py</files>
  <action>
Create `ea_stress/mt5/` package with interface protocol defining MT5 operations.

In `interface.py`:
1. Define result dataclasses (frozen=True, with to_dict/from_dict):
   - `CompileResult`: success, exe_path, errors, warnings
   - `BacktestResult`: success, profit, profit_factor, max_drawdown_pct, total_trades, win_rate, sharpe_ratio, expected_payoff, recovery_factor, equity_curve, report_path, errors
   - `OptimizationResult`: success, passes_count, results (list of pass dicts), best_result, xml_path, errors

2. Define `MT5Interface` as typing.Protocol with methods:
   - `compile(ea_path: Path) -> CompileResult`
   - `backtest(ea_path: Path, symbol: str, timeframe: str, params: dict | None, from_date: str | None, to_date: str | None, model: int | None, report_name: str | None) -> BacktestResult`
   - `optimize(ea_path: Path, symbol: str, timeframe: str, param_ranges: list[dict], report_name: str | None, timeout: int | None) -> OptimizationResult`

Use Protocol (not ABC) for structural subtyping - implementations don't need to inherit.

In `__init__.py`: Export all result types and MT5Interface.
  </action>
  <verify>python -c "from ea_stress.mt5 import MT5Interface, CompileResult, BacktestResult, OptimizationResult"</verify>
  <done>Interface protocol defined, all result dataclasses importable, no dependencies on old modules</done>
</task>

<task type="auto">
  <name>Task 2: Create terminal implementation</name>
  <files>ea_stress/mt5/terminal.py</files>
  <action>
Create `TerminalMT5` class implementing `MT5Interface` by delegating to existing modules.

Implementation:
1. Import from existing modules: `modules.compiler.compile_ea`, `modules.backtest.run_backtest`, `modules.optimizer.run_optimization`
2. `compile()`: Call `compile_ea()`, convert dict result to `CompileResult`
3. `backtest()`: Call `run_backtest()`, convert dict result to `BacktestResult`
4. `optimize()`: Call `run_optimization()`, convert dict result to `OptimizationResult`

Each method is a thin wrapper that:
- Accepts typed parameters
- Calls the existing module function
- Converts the untyped dict response to our typed dataclass

Do NOT refactor the existing modules - just wrap them. The old code stays as-is until Phase 8 migration.

Add to `__init__.py` exports.
  </action>
  <verify>python -c "from ea_stress.mt5 import TerminalMT5; t = TerminalMT5(); print(type(t))"</verify>
  <done>TerminalMT5 class created, wraps all three operations, converts results to typed dataclasses</done>
</task>

<task type="auto">
  <name>Task 3: Create dry-run implementation</name>
  <files>ea_stress/mt5/dry_run.py</files>
  <action>
Create `DryRunMT5` class implementing `MT5Interface` with configurable mock responses.

Implementation:
1. Constructor accepts optional overrides for default responses:
   ```python
   def __init__(
       self,
       compile_success: bool = True,
       compile_errors: list[str] | None = None,
       backtest_trades: int = 100,
       backtest_profit: float = 500.0,
       backtest_profit_factor: float = 1.8,
       backtest_max_drawdown_pct: float = 15.0,
       optimization_passes: int = 500,
       optimization_results: list[dict] | None = None,
   ):
   ```

2. `compile()`: Return `CompileResult` with configured success/errors. If success, set exe_path to input path with .ex5 extension.

3. `backtest()`: Return `BacktestResult` with configured metrics. Generate simple equity curve (linear from 10000 to 10000+profit).

4. `optimize()`: Return `OptimizationResult` with configured pass count. If optimization_results not provided, generate N passes with random-ish but deterministic metrics (use pass index as seed for reproducibility).

5. Add `call_log: list[tuple[str, dict]]` attribute that records every method call for test assertions.

Add to `__init__.py` exports.
  </action>
  <verify>python -c "from ea_stress.mt5 import DryRunMT5; d = DryRunMT5(); r = d.compile('test.mq5'); print(f'success={r.success}')"</verify>
  <done>DryRunMT5 class created with configurable responses, call logging for test assertions, no MT5 dependency</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -c "from ea_stress.mt5 import MT5Interface, TerminalMT5, DryRunMT5"` succeeds
- [ ] `python -c "from ea_stress.mt5 import CompileResult, BacktestResult, OptimizationResult"` succeeds
- [ ] DryRunMT5 can be instantiated and called without MT5 installed
- [ ] TerminalMT5 can be instantiated (imports succeed even if MT5 not available)
- [ ] No modifications to existing modules/ files
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- MT5Interface protocol defined with compile/backtest/optimize methods
- TerminalMT5 wraps existing modules without modifying them
- DryRunMT5 provides configurable mock responses
- Result dataclasses have to_dict/from_dict methods
- No new external dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/03-mt5-abstraction/03-01-SUMMARY.md` following the summary template.
</output>
