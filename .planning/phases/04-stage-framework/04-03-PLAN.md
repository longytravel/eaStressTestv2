---
phase: 04-stage-framework
plan: 03
type: execute
domain: python
---

<objective>
Implement Stage 2 - Compilation stage using MT5Interface.

Purpose: Create the compilation stage that uses the MT5 abstraction layer.
Output: `ea_stress/stages/s02_compile.py`
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Prior plan summaries:
@.planning/phases/04-stage-framework/04-01-SUMMARY.md
@.planning/phases/04-stage-framework/04-02-SUMMARY.md

# Key files:
@ea_stress/stages/base.py
@ea_stress/mt5/interface.py
@ea_stress/core/metrics.py

# Specifications:
@.planning/phases/01-specification/specs/step-02-compile.md

**Tech stack available:**
- MT5Interface with compile() method returning CompileResult
- StageResult, Stage from ea_stress.stages
- GateResult from ea_stress.core.metrics

**Established patterns:**
- Stages receive MT5Interface via execute() parameter
- Use CompileResult from MT5Interface.compile()
- Create GateResult based on compilation success
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Stage 2 - CompileStage</name>
  <files>ea_stress/stages/s02_compile.py</files>
  <action>
Create `ea_stress/stages/s02_compile.py`:

```python
class CompileStage:
    """Stage 2: Compile the EA using MetaEditor64."""

    @property
    def name(self) -> str:
        return "2_compile"

    def execute(self, state: WorkflowState, mt5: MT5Interface | None = None) -> StageResult:
        if mt5 is None:
            return StageResult(
                success=False,
                data={},
                gate=None,
                errors=("MT5 interface required for compilation",),
            )

        # Get path to compile - prefer modified EA from Step 1B if available
        step_1b = state.steps.get("1b_inject_ontester")
        if step_1b and step_1b.passed and step_1b.result:
            ea_path = Path(step_1b.result.get("modified_path", state.ea_path))
        else:
            ea_path = Path(state.ea_path)

        # Compile using MT5Interface
        result = mt5.compile(ea_path)

        # Create gate result
        error_count = len(result.errors)
        gate = GateResult(
            name="compilation",
            passed=result.success and error_count == 0,
            value=error_count,
            threshold=0,
            operator="==",
        )

        if result.success:
            return StageResult(
                success=True,
                data={
                    "source_path": str(ea_path),
                    "exe_path": result.exe_path,
                    "errors": list(result.errors),
                    "warnings": list(result.warnings),
                },
                gate=gate,
                errors=(),
            )
        else:
            return StageResult(
                success=False,
                data={
                    "source_path": str(ea_path),
                    "errors": list(result.errors),
                    "warnings": list(result.warnings),
                },
                gate=gate,
                errors=result.errors,
            )
```

Key points:
- REQUIRES mt5 parameter (unlike Stages 1, 1B, 1C)
- Uses MT5Interface.compile() which returns CompileResult
- Prefers modified_path from Step 1B if available
- Creates GateResult with error count check (must be 0)
- Stores exe_path in data for subsequent stages

Use TYPE_CHECKING imports for WorkflowState, MT5Interface.
  </action>
  <verify>python -c "from ea_stress.stages.s02_compile import CompileStage; s = CompileStage(); print(s.name)"</verify>
  <done>CompileStage uses MT5Interface.compile(), returns StageResult with exe_path and gate</done>
</task>

<task type="auto">
  <name>Task 2: Update stages __init__.py to export CompileStage</name>
  <files>ea_stress/stages/__init__.py</files>
  <action>
Update `ea_stress/stages/__init__.py` to include CompileStage in the lazy exports:

Add to the lazy import mapping:
- "CompileStage": ("s02_compile", "CompileStage")

Ensure __all__ includes CompileStage.

Verify the lazy import pattern works correctly for all 4 stage classes:
- LoadEAStage
- InjectOnTesterStage
- InjectSafetyStage
- CompileStage
  </action>
  <verify>python -c "from ea_stress.stages import CompileStage; print(CompileStage)"</verify>
  <done>CompileStage exported from ea_stress.stages package</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] CompileStage satisfies Stage protocol (name property, execute method)
- [ ] CompileStage requires mt5 parameter (returns error if None)
- [ ] Uses MT5Interface.compile() and CompileResult
- [ ] Creates GateResult with compilation error count check
- [ ] exe_path included in result data
- [ ] Exported from ea_stress.stages
- [ ] `python -m pytest -q` passes
</verification>

<success_criteria>

- CompileStage class created
- Satisfies Stage protocol
- Uses MT5Interface abstraction (not modules/compiler.py directly)
- Exported from ea_stress.stages
- pytest passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-stage-framework/04-03-SUMMARY.md`
</output>
