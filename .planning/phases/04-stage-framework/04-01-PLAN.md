---
phase: 04-stage-framework
plan: 01
type: execute
domain: python
---

<objective>
Create the Stage base interface and framework for implementing workflow stages.

Purpose: Define the contract that all stages follow - inputs, execution, outputs, validation.
Output: `ea_stress/stages/base.py` with Stage protocol and supporting types.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (dependencies):
@.planning/phases/02-core-domain/02-01-SUMMARY.md
@.planning/phases/03-mt5-abstraction/03-01-SUMMARY.md

# Key files from prior phases:
@ea_stress/core/state.py
@ea_stress/mt5/interface.py

# Specifications:
@.planning/phases/01-specification/specs/step-01-load-ea.md
@.planning/phases/01-specification/specs/step-02-compile.md

**Tech stack available:**
- dataclasses (frozen for results, mutable for state)
- typing.Protocol for structural subtyping
- to_dict/from_dict for serialization

**Established patterns:**
- Frozen dataclasses for operation results (immutable snapshots)
- Protocol for interfaces (structural subtyping, no inheritance required)
- Lazy imports via __getattr__ to avoid circular imports
- Method-level imports in implementations (not at module level)

**Constraining decisions:**
- Phase 2: Use dataclasses with explicit type hints
- Phase 3: Use Protocol for structural subtyping
- Phase 3: Use tuples in frozen dataclasses (hashable)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stages package with StageResult dataclass</name>
  <files>ea_stress/stages/__init__.py, ea_stress/stages/base.py</files>
  <action>
Create the stages package structure:

1. `ea_stress/stages/__init__.py`:
   - Export StageResult, Stage
   - Use lazy imports via __getattr__ for stage implementations (to be added later)

2. `ea_stress/stages/base.py`:
   - Create `StageResult` frozen dataclass with:
     - `success: bool` - Whether stage passed
     - `data: dict[str, Any]` - Stage-specific output data
     - `gate: GateResult | None` - Gate check result (if applicable)
     - `errors: tuple[str, ...]` - Error messages
   - Include to_dict/from_dict methods for serialization

Follow existing patterns: frozen=True, tuple instead of list for sequences, explicit type hints.
  </action>
  <verify>python -c "from ea_stress.stages import StageResult; r = StageResult(success=True, data={}); print(r.to_dict())"</verify>
  <done>StageResult dataclass importable and serializable, package structure created</done>
</task>

<task type="auto">
  <name>Task 2: Create Stage protocol with execute method</name>
  <files>ea_stress/stages/base.py</files>
  <action>
Add the `Stage` Protocol to base.py:

```python
class Stage(Protocol):
    """Protocol for workflow stages.

    Each stage:
    1. Has a name (step identifier like "1_load_ea")
    2. Takes inputs via constructor or execute params
    3. Returns StageResult with success/data/gate/errors
    """

    @property
    def name(self) -> str:
        """Step name as used in WORKFLOW_STEPS (e.g., '1_load_ea')."""
        ...

    def execute(self, state: WorkflowState, mt5: MT5Interface | None = None) -> StageResult:
        """Execute the stage.

        Args:
            state: Current workflow state (for reading prior step results)
            mt5: MT5 interface for operations requiring MT5 (compile, backtest, optimize)
                 Pass None for stages that don't need MT5.

        Returns:
            StageResult with success status, output data, and gate result
        """
        ...
```

Import WorkflowState from ea_stress.core.state and MT5Interface from ea_stress.mt5.interface.

AVOID importing at module level - use TYPE_CHECKING for type hints only:
```python
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from ea_stress.core.state import WorkflowState
    from ea_stress.mt5.interface import MT5Interface
```
  </action>
  <verify>python -c "from ea_stress.stages import Stage; print(Stage.__protocol_attrs__)"</verify>
  <done>Stage protocol defined with name property and execute method, no circular imports</done>
</task>

<task type="auto">
  <name>Task 3: Add StageContext dataclass for shared stage dependencies</name>
  <files>ea_stress/stages/base.py, ea_stress/stages/__init__.py</files>
  <action>
Add `StageContext` dataclass to base.py - bundles common dependencies stages need:

```python
@dataclass
class StageContext:
    """Context passed to stages with common dependencies.

    Avoids passing many individual parameters to each stage.
    Mutable so stages can update shared state if needed.
    """
    ea_path: Path                    # Original EA source path
    symbol: str = "EURUSD"           # Trading symbol
    timeframe: str = "H1"            # Chart timeframe
    terminal_config: dict | None = None  # MT5 terminal config (for compile)
    modified_ea_path: Path | None = None  # Path after injection (set by Stage 1B)
    compiled_ea_path: Path | None = None  # Path after compile (set by Stage 2)

    # Analysis results (set by LLM pause points)
    wide_validation_params: dict[str, Any] | None = None
    optimization_ranges: list[dict[str, Any]] | None = None
```

Update __init__.py to export StageContext.

This context is MUTABLE (not frozen) because stages update it as they execute:
- Stage 1B sets modified_ea_path
- Stage 2 sets compiled_ea_path
- Stage 4 receives wide_validation_params and optimization_ranges
  </action>
  <verify>python -c "from ea_stress.stages import StageContext; from pathlib import Path; c = StageContext(ea_path=Path('test.mq5')); c.modified_ea_path = Path('test_modified.mq5'); print(c)"</verify>
  <done>StageContext dataclass created and exported, mutable for stage updates</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from ea_stress.stages import StageResult, Stage, StageContext"` - all imports work
- [ ] StageResult is frozen (immutable)
- [ ] StageContext is mutable (stages can update paths)
- [ ] Stage protocol has name property and execute method
- [ ] No circular imports (use TYPE_CHECKING for type hints)
- [ ] `python -m pytest -q` passes
</verification>

<success_criteria>

- ea_stress/stages/ package created with base.py
- StageResult frozen dataclass with to_dict/from_dict
- Stage protocol with name property and execute method
- StageContext mutable dataclass for shared dependencies
- All exports available from ea_stress.stages
- No modifications to existing code (additive only)
- pytest passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-stage-framework/04-01-SUMMARY.md`
</output>
