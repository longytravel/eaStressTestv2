---
phase: 04-stage-framework
plan: 04
type: execute
domain: python
---

<objective>
Implement Stages 3 and 4 - Parameter extraction and analysis pause point.

Purpose: Create the parameter extraction stage and the LLM pause point stage.
Output: `ea_stress/stages/s03_extract_params.py`, `ea_stress/stages/s04_analyze_params.py`
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Prior plan summaries:
@.planning/phases/04-stage-framework/04-01-SUMMARY.md
@.planning/phases/04-stage-framework/04-02-SUMMARY.md
@.planning/phases/04-stage-framework/04-03-SUMMARY.md

# Key files:
@ea_stress/stages/base.py
@ea_stress/core/params.py
@ea_stress/core/metrics.py

# Specifications:
@.planning/phases/01-specification/specs/step-03-extract-params.md
@.planning/phases/01-specification/specs/step-04-analyze-params.md

# Existing implementation (wrap, don't modify):
@modules/params.py

**Tech stack available:**
- Parameter, OptimizationRange from ea_stress.core.params
- StageResult, Stage from ea_stress.stages
- GateResult from ea_stress.core.metrics

**Established patterns:**
- Wrap existing modules/params.py extraction
- Convert dict params to Parameter dataclasses
- Stage 4 is a pause point (sets status, returns immediately)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Stage 3 - ExtractParamsStage</name>
  <files>ea_stress/stages/s03_extract_params.py</files>
  <action>
Create `ea_stress/stages/s03_extract_params.py`:

```python
class ExtractParamsStage:
    """Stage 3: Extract input parameters from EA source code."""

    @property
    def name(self) -> str:
        return "3_extract_params"

    def execute(self, state: WorkflowState, mt5: MT5Interface | None = None) -> StageResult:
        # Get source path - prefer modified EA if available
        step_1b = state.steps.get("1b_inject_ontester")
        if step_1b and step_1b.passed and step_1b.result:
            source_path = step_1b.result.get("modified_path", state.ea_path)
        else:
            source_path = state.ea_path

        try:
            # Use existing extractor
            from modules.params import extract_params
            params_dicts = extract_params(str(source_path))

            # Convert to Parameter dataclasses (optional - keep as dicts for now for compatibility)
            # The Pipeline can convert to Parameter objects if needed

            count = len(params_dicts)
            optimizable = sum(1 for p in params_dicts if p.get("optimizable", False))

            # Gate: at least one parameter found
            gate = GateResult(
                name="params_found",
                passed=count > 0,
                value=count,
                threshold=1,
                operator=">=",
            )

            return StageResult(
                success=count > 0,
                data={
                    "params": params_dicts,
                    "count": count,
                    "optimizable": optimizable,
                    "source_path": source_path,
                },
                gate=gate,
                errors=() if count > 0 else ("No parameters found in EA",),
            )

        except Exception as e:
            return StageResult(
                success=False,
                data={"source_path": source_path},
                gate=None,
                errors=(str(e),),
            )
```

This stage:
- Wraps modules/params.extract_params()
- Returns parameter dicts (keeping legacy format for compatibility)
- Creates gate for "at least 1 param found"
- Stage 4 will process these params (LLM pause point)

After this stage succeeds, the workflow pauses for parameter analysis.
  </action>
  <verify>python -c "from ea_stress.stages.s03_extract_params import ExtractParamsStage; s = ExtractParamsStage(); print(s.name)"</verify>
  <done>ExtractParamsStage wraps param extraction, returns params list with gate</done>
</task>

<task type="auto">
  <name>Task 2: Implement Stage 4 - AnalyzeParamsStage (pause point)</name>
  <files>ea_stress/stages/s04_analyze_params.py</files>
  <action>
Create `ea_stress/stages/s04_analyze_params.py`:

```python
class AnalyzeParamsStage:
    """Stage 4: Analyze parameters (LLM pause point).

    This stage is special - it's a pause point where the workflow
    waits for external input (from /param-analyzer skill or auto-analysis).

    When executed WITHOUT analysis data: Returns success=True with empty data,
    and the pipeline should transition to AWAITING_PARAM_ANALYSIS status.

    When executed WITH analysis data (via continue_with_params): Validates
    and stores the wide_validation_params and optimization_ranges.
    """

    def __init__(self):
        self._wide_params: dict | None = None
        self._opt_ranges: list[dict] | None = None

    @property
    def name(self) -> str:
        return "4_analyze_params"

    def set_analysis_data(
        self,
        wide_validation_params: dict,
        optimization_ranges: list[dict],
    ) -> None:
        """Set analysis data before execution (called by pipeline on resume)."""
        self._wide_params = wide_validation_params
        self._opt_ranges = optimization_ranges

    def execute(self, state: WorkflowState, mt5: MT5Interface | None = None) -> StageResult:
        # Check if we have analysis data
        if self._wide_params is None or self._opt_ranges is None:
            # No analysis data - this is the initial pause
            return StageResult(
                success=True,  # Step "succeeds" but pipeline pauses
                data={
                    "status": "awaiting_param_analysis",
                    "message": "Waiting for parameter analysis from /param-analyzer skill",
                },
                gate=None,
                errors=(),
            )

        # Validate the analysis data
        errors = self._validate_analysis()
        if errors:
            return StageResult(
                success=False,
                data={},
                gate=None,
                errors=tuple(errors),
            )

        # Analysis data valid - store and return success
        gate = GateResult(
            name="params_analyzed",
            passed=True,
            value=len(self._opt_ranges),
            threshold=1,
            operator=">=",
        )

        return StageResult(
            success=True,
            data={
                "source": "param_analysis",
                "wide_validation_params": self._wide_params,
                "wide_param_count": len(self._wide_params),
                "optimization_ranges": self._opt_ranges,
                "optimization_param_count": len(self._opt_ranges),
            },
            gate=gate,
            errors=(),
        )

    def _validate_analysis(self) -> list[str]:
        """Validate the analysis data. Returns list of error messages."""
        errors = []

        if not self._wide_params:
            errors.append("wide_validation_params is empty")

        if not self._opt_ranges:
            errors.append("optimization_ranges is empty")

        # Check each range has required fields
        required_fields = {"name", "start", "step", "stop", "optimize"}
        for i, r in enumerate(self._opt_ranges or []):
            missing = required_fields - set(r.keys())
            if missing:
                errors.append(f"Range {i} missing fields: {missing}")

        return errors
```

Key design:
- Stage 4 is stateful - has set_analysis_data() method
- First execution (no data): Returns "awaiting" status for pipeline to pause
- Resume execution (with data): Validates and stores analysis results
- Pipeline calls set_analysis_data() before re-executing on resume
  </action>
  <verify>python -c "from ea_stress.stages.s04_analyze_params import AnalyzeParamsStage; s = AnalyzeParamsStage(); print(s.name)"</verify>
  <done>AnalyzeParamsStage handles pause point pattern, validates analysis data on resume</done>
</task>

<task type="auto">
  <name>Task 3: Update stages __init__.py exports</name>
  <files>ea_stress/stages/__init__.py</files>
  <action>
Update `ea_stress/stages/__init__.py` to include new stage exports:

Add to lazy import mapping:
- "ExtractParamsStage": ("s03_extract_params", "ExtractParamsStage")
- "AnalyzeParamsStage": ("s04_analyze_params", "AnalyzeParamsStage")

Ensure __all__ includes both new stage classes.

All 6 stages should now be exportable:
- LoadEAStage
- InjectOnTesterStage
- InjectSafetyStage
- CompileStage
- ExtractParamsStage
- AnalyzeParamsStage
  </action>
  <verify>python -c "from ea_stress.stages import ExtractParamsStage, AnalyzeParamsStage; print('stages 3 and 4 imported')"</verify>
  <done>ExtractParamsStage and AnalyzeParamsStage exported from package</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ExtractParamsStage wraps modules/params.extract_params()
- [ ] ExtractParamsStage creates gate for params_found
- [ ] AnalyzeParamsStage has set_analysis_data() method
- [ ] AnalyzeParamsStage returns awaiting status when no data
- [ ] AnalyzeParamsStage validates analysis data
- [ ] Both stages exported from ea_stress.stages
- [ ] `python -m pytest -q` passes
</verification>

<success_criteria>

- ExtractParamsStage and AnalyzeParamsStage created
- Both satisfy Stage protocol
- AnalyzeParamsStage handles pause/resume pattern
- Exported from ea_stress.stages
- pytest passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-stage-framework/04-04-SUMMARY.md`
</output>
