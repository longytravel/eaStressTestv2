---
phase: 04-stage-framework
plan: 02
type: execute
domain: python
---

<objective>
Implement Stages 1, 1B, and 1C - file loading and code injection stages.

Purpose: Create the initial preparation stages that load and modify the EA source code.
Output: `ea_stress/stages/s01_load.py`, `ea_stress/stages/s01b_inject_ontester.py`, `ea_stress/stages/s01c_inject_safety.py`
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Prior plan summary (for this phase):
@.planning/phases/04-stage-framework/04-01-SUMMARY.md

# Key files:
@ea_stress/stages/base.py
@ea_stress/core/metrics.py

# Specifications:
@.planning/phases/01-specification/specs/step-01-load-ea.md
@.planning/phases/01-specification/specs/step-01b-inject-ontester.md
@.planning/phases/01-specification/specs/step-01c-inject-safety.md

# Existing implementation (wrap, don't modify):
@modules/injector.py

**Tech stack available:**
- StageResult, Stage, StageContext from ea_stress.stages
- GateResult from ea_stress.core.metrics

**Established patterns:**
- Stages satisfy Protocol through duck typing (no inheritance)
- Wrap existing modules/injector.py functions
- Return StageResult with success, data, gate, errors
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Stage 1 - LoadEA stage</name>
  <files>ea_stress/stages/s01_load.py</files>
  <action>
Create `ea_stress/stages/s01_load.py`:

```python
class LoadEAStage:
    """Stage 1: Verify EA file exists."""

    @property
    def name(self) -> str:
        return "1_load_ea"

    def execute(self, state: WorkflowState, mt5: MT5Interface | None = None) -> StageResult:
        # Get ea_path from state
        ea_path = Path(state.ea_path)

        # Check file exists
        exists = ea_path.exists()

        # Create gate result
        gate = GateResult(
            name="file_exists",
            passed=exists,
            value=1 if exists else 0,
            threshold=1,
            operator="==",
        )

        return StageResult(
            success=exists,
            data={"path": str(ea_path), "exists": exists},
            gate=gate,
            errors=() if exists else (f"EA file not found: {ea_path}",),
        )
```

Use TYPE_CHECKING for imports. The stage reads ea_path from WorkflowState.ea_path.

The stage does NOT need mt5 parameter (pure file check).
  </action>
  <verify>python -c "from ea_stress.stages.s01_load import LoadEAStage; s = LoadEAStage(); print(s.name)"</verify>
  <done>LoadEAStage class created, satisfies Stage protocol, returns proper StageResult with gate</done>
</task>

<task type="auto">
  <name>Task 2: Implement Stage 1B - InjectOnTester stage</name>
  <files>ea_stress/stages/s01b_inject_ontester.py</files>
  <action>
Create `ea_stress/stages/s01b_inject_ontester.py`:

```python
class InjectOnTesterStage:
    """Stage 1B: Inject OnTester function for custom optimization criterion."""

    @property
    def name(self) -> str:
        return "1b_inject_ontester"

    def execute(self, state: WorkflowState, mt5: MT5Interface | None = None) -> StageResult:
        # Import the existing module inside the method (lazy import)
        from modules.injector import create_modified_ea

        ea_path = state.ea_path

        # Call existing injector
        result = create_modified_ea(
            str(ea_path),
            inject_tester=True,
            inject_guards=False,  # Safety guards in separate step
        )

        if result["success"]:
            return StageResult(
                success=True,
                data={
                    "original_path": str(ea_path),
                    "modified_path": result["modified_path"],
                    "ontester_injected": result.get("ontester_injected", True),
                    "safety_injected": False,
                },
                gate=None,  # No gate for this step
                errors=(),
            )
        else:
            return StageResult(
                success=False,
                data={"original_path": str(ea_path)},
                gate=None,
                errors=tuple(result.get("errors", ["Injection failed"])),
            )
```

This wraps the existing `modules/injector.create_modified_ea()` function.
The stage does NOT modify the injector module - it's a thin adapter.

IMPORTANT: The modified_path needs to be tracked for subsequent stages. The pipeline/runner will store this in StageContext.modified_ea_path based on the returned data.
  </action>
  <verify>python -c "from ea_stress.stages.s01b_inject_ontester import InjectOnTesterStage; s = InjectOnTesterStage(); print(s.name)"</verify>
  <done>InjectOnTesterStage wraps existing injector, returns StageResult with modified_path</done>
</task>

<task type="auto">
  <name>Task 3: Implement Stage 1C - InjectSafety stage</name>
  <files>ea_stress/stages/s01c_inject_safety.py, ea_stress/stages/__init__.py</files>
  <action>
Create `ea_stress/stages/s01c_inject_safety.py`:

```python
class InjectSafetyStage:
    """Stage 1C: Inject safety guards into modified EA."""

    @property
    def name(self) -> str:
        return "1c_inject_safety"

    def execute(self, state: WorkflowState, mt5: MT5Interface | None = None) -> StageResult:
        # Need the modified EA path from Step 1B
        step_1b = state.steps.get("1b_inject_ontester")
        if not step_1b or not step_1b.passed:
            return StageResult(
                success=False,
                data={},
                gate=None,
                errors=("Step 1B must complete successfully first",),
            )

        modified_path = step_1b.result.get("modified_path") if step_1b.result else None
        if not modified_path:
            return StageResult(
                success=False,
                data={},
                gate=None,
                errors=("No modified EA path from Step 1B",),
            )

        # Import and run safety injection
        from modules.injector import inject_safety
        from pathlib import Path

        try:
            content = Path(modified_path).read_text(encoding="utf-8")
            content, injected = inject_safety(content)
            Path(modified_path).write_text(content, encoding="utf-8")

            return StageResult(
                success=True,
                data={
                    "path": modified_path,
                    "safety_injected": injected,
                },
                gate=None,
                errors=(),
            )
        except Exception as e:
            return StageResult(
                success=False,
                data={"path": modified_path},
                gate=None,
                errors=(str(e),),
            )
```

This stage reads the modified_path from Step 1B's result in state.steps.

Update `ea_stress/stages/__init__.py` to lazily export the three stage classes:
- LoadEAStage
- InjectOnTesterStage
- InjectSafetyStage

Use __getattr__ pattern for lazy imports.
  </action>
  <verify>python -c "from ea_stress.stages import LoadEAStage, InjectOnTesterStage, InjectSafetyStage; print('all stages imported')"</verify>
  <done>InjectSafetyStage reads Step 1B result, injects safety, all three stages exported from package</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All three stage classes satisfy Stage protocol (name property, execute method)
- [ ] LoadEAStage creates GateResult for file_exists check
- [ ] InjectOnTesterStage wraps modules/injector.create_modified_ea()
- [ ] InjectSafetyStage reads modified_path from Step 1B result
- [ ] All stages importable from ea_stress.stages
- [ ] No modifications to modules/injector.py
- [ ] `python -m pytest -q` passes
</verification>

<success_criteria>

- Three stage classes created: LoadEAStage, InjectOnTesterStage, InjectSafetyStage
- Each satisfies Stage protocol
- Stages wrap existing code without modifying it
- All stages exported from ea_stress.stages package
- pytest passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-stage-framework/04-02-SUMMARY.md`
</output>
