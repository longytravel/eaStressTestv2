---
phase: 04-stage-framework
plan: 05
type: execute
domain: python
---

<objective>
Implement Stage 5 - Trade validation backtest stage.

Purpose: Create the validation stage that proves the EA can generate trades.
Output: `ea_stress/stages/s05_validate_trades.py`
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Prior plan summaries:
@.planning/phases/04-stage-framework/04-01-SUMMARY.md
@.planning/phases/04-stage-framework/04-02-SUMMARY.md
@.planning/phases/04-stage-framework/04-03-SUMMARY.md
@.planning/phases/04-stage-framework/04-04-SUMMARY.md

# Key files:
@ea_stress/stages/base.py
@ea_stress/mt5/interface.py
@ea_stress/core/metrics.py

# Specifications:
@.planning/phases/01-specification/specs/step-05-validate-trades.md

# Settings reference:
@settings.py

**Tech stack available:**
- MT5Interface with backtest() method returning BacktestResult
- StageResult, Stage from ea_stress.stages
- GateResult from ea_stress.core.metrics

**Established patterns:**
- Use MT5Interface.backtest() for the validation run
- Get wide_validation_params from Step 4 result
- Create gate for minimum trades check
- settings.MIN_TRADES is the threshold (default: 50)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Stage 5 - ValidateTradesStage</name>
  <files>ea_stress/stages/s05_validate_trades.py</files>
  <action>
Create `ea_stress/stages/s05_validate_trades.py`:

```python
class ValidateTradesStage:
    """Stage 5: Run validation backtest to prove EA generates trades."""

    @property
    def name(self) -> str:
        return "5_validate_trades"

    def execute(self, state: WorkflowState, mt5: MT5Interface | None = None) -> StageResult:
        if mt5 is None:
            return StageResult(
                success=False,
                data={},
                gate=None,
                errors=("MT5 interface required for backtest",),
            )

        # Get compiled EA path from Step 2
        step_2 = state.steps.get("2_compile")
        if not step_2 or not step_2.passed or not step_2.result:
            return StageResult(
                success=False,
                data={},
                gate=None,
                errors=("Step 2 (compile) must complete successfully first",),
            )
        exe_path = step_2.result.get("exe_path")
        if not exe_path:
            return StageResult(
                success=False,
                data={},
                gate=None,
                errors=("No compiled EA path from Step 2",),
            )

        # Get wide_validation_params from Step 4
        step_4 = state.steps.get("4_analyze_params")
        if not step_4 or not step_4.passed or not step_4.result:
            return StageResult(
                success=False,
                data={},
                gate=None,
                errors=("Step 4 (analyze params) must complete successfully first",),
            )
        wide_params = step_4.result.get("wide_validation_params")
        if not wide_params:
            return StageResult(
                success=False,
                data={},
                gate=None,
                errors=("No wide_validation_params from Step 4",),
            )

        # Import settings for MIN_TRADES threshold
        import settings

        # Apply safety param overrides for validation (loose limits)
        params = dict(wide_params)
        params["EAStressSafety_MaxSpreadPips"] = getattr(
            settings, "SAFETY_VALIDATION_MAX_SPREAD_PIPS", 500.0
        )
        params["EAStressSafety_MaxSlippagePips"] = getattr(
            settings, "SAFETY_VALIDATION_MAX_SLIPPAGE_PIPS", 500.0
        )

        # Generate deterministic report name
        report_name = f"S5_validate_{state.symbol}_{state.timeframe}_{state.workflow_id[:8]}"

        # Run backtest
        result = mt5.backtest(
            ea_path=Path(exe_path),
            symbol=state.symbol,
            timeframe=state.timeframe,
            params=params,
            report_name=report_name,
        )

        # Check trade count against threshold
        min_trades = getattr(settings, "MIN_TRADES", 50)
        trades = result.total_trades

        gate = GateResult(
            name="minimum_trades",
            passed=trades >= min_trades,
            value=trades,
            threshold=min_trades,
            operator=">=",
        )

        data = {
            "total_trades": trades,
            "profit": result.profit,
            "profit_factor": result.profit_factor,
            "max_drawdown_pct": result.max_drawdown_pct,
            "win_rate": result.win_rate,
            "report_path": result.report_path,
        }

        if gate.passed:
            return StageResult(
                success=True,
                data=data,
                gate=gate,
                errors=(),
            )
        else:
            return StageResult(
                success=False,
                data=data,
                gate=gate,
                errors=(f"Only {trades} trades, minimum is {min_trades}",),
            )
```

Key points:
- REQUIRES mt5 parameter
- Gets exe_path from Step 2 result
- Gets wide_validation_params from Step 4 result
- Applies loose safety limits for validation
- Creates gate for minimum trades check
- Returns all backtest metrics in data
  </action>
  <verify>python -c "from ea_stress.stages.s05_validate_trades import ValidateTradesStage; s = ValidateTradesStage(); print(s.name)"</verify>
  <done>ValidateTradesStage uses MT5Interface.backtest(), checks trade count gate</done>
</task>

<task type="auto">
  <name>Task 2: Update stages __init__.py exports and verify all stages</name>
  <files>ea_stress/stages/__init__.py</files>
  <action>
Update `ea_stress/stages/__init__.py` to include ValidateTradesStage:

Add to lazy import mapping:
- "ValidateTradesStage": ("s05_validate_trades", "ValidateTradesStage")

Update __all__ to include all 7 exports from this phase:
- StageResult
- Stage
- StageContext
- LoadEAStage
- InjectOnTesterStage
- InjectSafetyStage
- CompileStage
- ExtractParamsStage
- AnalyzeParamsStage
- ValidateTradesStage

Verify complete stage coverage for Stages 1-5.
  </action>
  <verify>python -c "from ea_stress.stages import ValidateTradesStage, StageResult, Stage, StageContext; print('all Phase 4 exports work')"</verify>
  <done>ValidateTradesStage exported, all Phase 4 stage classes available from package</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ValidateTradesStage satisfies Stage protocol
- [ ] ValidateTradesStage requires mt5 parameter
- [ ] Gets exe_path from Step 2 result
- [ ] Gets wide_validation_params from Step 4 result
- [ ] Applies safety param overrides
- [ ] Creates minimum_trades gate
- [ ] All 7 stages exported from ea_stress.stages
- [ ] `python -m pytest -q` passes
</verification>

<success_criteria>

- ValidateTradesStage class created
- Satisfies Stage protocol
- Uses MT5Interface.backtest()
- Exported from ea_stress.stages
- Phase 4 complete - all stages 1-5 implemented
- pytest passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-stage-framework/04-05-SUMMARY.md` with:
- All 7 stage classes implemented
- Phase 4 complete summary
- Ready for Phase 5 (remaining stages 6-14)
</output>
