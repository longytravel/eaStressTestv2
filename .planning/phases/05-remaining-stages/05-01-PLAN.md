---
phase: 05-remaining-stages
plan: 01
type: execute
---

<objective>
Implement FixEAStage (Step 5B) for the conditional retry loop when validation fails.

Purpose: Provide state management for the fix-EA workflow pause point.
Output: `ea_stress/stages/s05b_fix_ea.py` with FixEAStage class.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries:
@.planning/phases/04-stage-framework/04-01-SUMMARY.md
@.planning/phases/04-stage-framework/04-05-SUMMARY.md

# Specifications:
@.planning/phases/01-specification/specs/step-05b-fix-ea.md

# Existing patterns:
@ea_stress/stages/base.py
@ea_stress/stages/s05_validate_trades.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FixEAStage class</name>
  <files>ea_stress/stages/s05b_fix_ea.py</files>
  <action>
Create FixEAStage following the Stage protocol pattern from base.py.

The stage handles the workflow pause point when Step 5 fails:
1. Check if fix_attempts < max_fix_attempts (default 3)
2. Set workflow status to 'awaiting_ea_fix' if retries remain
3. Return StageResult with data containing:
   - fix_attempts: current attempt number
   - max_fix_attempts: limit (from settings or default 3)
   - awaiting_fix: True if waiting for LLM fix

Gate: Same minimum_trades gate as Step 5 (re-checked after fix).

Key behaviors from spec:
- This is a workflow pause point, not an automated fix
- The actual fixing is done by /mql5-fixer skill externally
- Stage tracks attempt count and signals workflow to pause
- After fix applied externally, workflow restarts from Step 1

Use pattern from s05_validate_trades.py for structure.
Import settings for MAX_FIX_ATTEMPTS (default 3).
  </action>
  <verify>python -c "from ea_stress.stages.s05b_fix_ea import FixEAStage; print(FixEAStage().name)"</verify>
  <done>FixEAStage class exists with name property returning '5b_fix_ea'</done>
</task>

<task type="auto">
  <name>Task 2: Export FixEAStage from stages package</name>
  <files>ea_stress/stages/__init__.py</files>
  <action>
Add FixEAStage to the lazy import pattern in __init__.py.

Update _stage_modules dict to include:
  "FixEAStage": "s05b_fix_ea"

Add to __all__ list.
  </action>
  <verify>python -c "from ea_stress.stages import FixEAStage; print(FixEAStage().name)"</verify>
  <done>FixEAStage importable from ea_stress.stages package</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from ea_stress.stages import FixEAStage"` succeeds
- [ ] `python -m pytest -q` passes all existing tests
- [ ] FixEAStage.name returns "5b_fix_ea"
</verification>

<success_criteria>

- FixEAStage implemented following Stage protocol
- Stage handles retry count tracking
- Stage signals workflow pause via status
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-remaining-stages/05-01-SUMMARY.md`
</output>
